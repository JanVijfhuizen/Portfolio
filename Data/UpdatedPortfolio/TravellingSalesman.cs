using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Linq;

public class TravellingSalesman {

    // This is used for threading
    public bool Alive { get; set; }

    public Vector2[] Cities { get; private set; }

    public int GenerationNumber { get; private set; }
    // The optimal distance calculated
    public float Distance { get; private set; }
    
    // List of all the possible semi-random solutions currently calculated
    private List<Solution> generation;
    // I prefer system random over unityengine random not only because it doesn't generate garbage and is not as expensive,
    // but mainly because if I make a mistake in my code and it bugs .x percent of the time, when I use a seed the exact same
    // thing will happen again, making very rare bugs more easily solvable
    private System.Random random;
    // This is used to mutate the current solutions
    private double mutationChance;
    private int generationSize,
        childrenAmount,
        newAmount;

    // The solution will be sorted based on it's calculated distance
    private class Solution : IComparable<Solution>
    {
        // The order of the cities in this path, where the values are the index for the array "cities"
        public List<int> Order { get; private set; }
        public float Distance { get; private set; }

        // Used to intitialize the lists with a certain size, which saves on garbage generated
        private int size;
        private System.Random random;
        private double mutationChance;
        // Reference to the "cities" array back in TravellingSalesman
        private Vector2[] cities;

        public Solution(int size, System.Random random, double mutationChance, Vector2[] cities)
        {
            this.size = size;
            this.random = random;
            this.mutationChance = mutationChance;
            this.cities = cities;

            // Add order in a set order, this will be randomized in ConvertToNew
            Order = new List<int>(size);
            for (int i = 0; i < size; i++)
                Order.Add(i);

            // While not rated, the value will be the worst it will ever get
            Distance = int.MaxValue;

            leftOverIndexes = new List<int>(size);

            ConvertToNew();
        }

        // Randomly swap values in the order list
        public void Mutate()
        {
            int swappedIndex, swappedValue;
            for (int i = 0; i < size; i++)
            {
                if (random.NextDouble() > mutationChance)
                    continue;

                swappedIndex = random.Next(0, size - 1);
                swappedValue = Order[swappedIndex];

                Order[swappedIndex] = Order[i];
                Order[i] = swappedValue;
            }
        }

        // Cache
        List<int> leftOverIndexes;

        // Instead of throwing non functional solutions away I'm reusing them to make them into new ones,
        // which saves on garbage
        public void ConvertToNew()
        {
            for (int i = 0; i < size; i++)
                leftOverIndexes.Add(i);

            int index;

            for (int i = 0; i < size; i++)
            {
                index = random.Next(1, size - i) - 1;
                Order[i] = leftOverIndexes[index];
                leftOverIndexes.RemoveAt(index);
            }
        }

        // As said above, I try to minimize the garbage generated by reusing data that would be thrown away anyway
        public void ConvertToChild(Solution other)
        {
            for (int i = 0; i < size; i++)
                Order[i] = other.Order[i];
            Mutate();
        }

        // Calculate the distance of the generated path
        public void Rate()
        {
            int length = size - 1;
            Distance = 0;
            for (int i = 0; i < length; i++)
                Distance += Vector2.Distance(cities[Order[i]], cities[Order[i + 1]]);
        }

        public int CompareTo(Solution other)
        {
            return Mathf.RoundToInt(Distance - other.Distance);
        }
    }

	public TravellingSalesman(Vector2[] cities, System.Random random, double mutationChance, int generationSize, int childrenAmount, int newAmount)
    {
        Cities = cities;

        this.random = random;
        this.mutationChance = mutationChance;
        this.generationSize = generationSize;
        this.childrenAmount = childrenAmount;
        this.newAmount = newAmount;

        int citiesLength = cities.Length;
        generation = new List<Solution>(citiesLength);
        for (int i = 0; i < generationSize; i++)
            generation.Add(new Solution(citiesLength, random, mutationChance, cities));
    }

    public void Cycle()
    {
        // Rate all solutions and order them based on their effectiveness
        foreach (Solution solution in generation)
            solution.Rate();
        generation.Sort();

        // Set public stats
        GenerationNumber++;
        Distance = generation[0].Distance;

        int start = generationSize - 1, 
            end = generationSize - childrenAmount,
            succeedAmount = generationSize - childrenAmount - newAmount;

        // Make children
        for (int i = start; i > end; i--)
            generation[i].ConvertToChild(generation[random.Next(0, succeedAmount)]);

        // Make new
        start = end;
        end = succeedAmount;
        for (int i = start; i < end; i--)
            generation[i].ConvertToNew();
    }

    // Used for multithreading
    public void InfiniteCycle()
    {
        Alive = true;
        while (Alive)
            Cycle();
    }
}
